https://www.infoq.com/articles/build-a-container-golang/
生词
arbitrary 任意的；武断的；随心所欲的；专横的
insecure

我想玩个游戏。现在，在你的脑海里思考，然后告诉我“容器(container)”是什么。好了吗？好吧。让我猜猜你会说什么:

你可能会想到下面一点或更多：

* 一种共享资源的方式
* 进程隔离
* 有点像轻量级的虚拟化
* 将根文件系统和元数据打包在一起
* 有点像 chroot jail
* 集装箱什么的
* docker所做的一切

一个词的意思太多了！“容器”这个词已经开始用于许多(有时是重叠的)概念。它被用于类似容器化，以及用于实现它的技术。如果我们把这些分开考虑，我们会得到一个更清晰的画面。那么，让我们来讨论一下为什么要使用容器，以及如何使用容器。(然后我们再说回为什么使用容器)。

## 起初,
最初，有这么一个程序。让我们称之为run.sh,现在需要把它拷贝到一个远程服务器上,并且运行它。然而，在远程计算机上运行任意代码是不安全的，并且难以管理和扩展。所以我们发明了虚拟专用服务器和用户权限。一切都很顺利。

但是run.sh有一些依赖项，它需要主机有某些库，而且它在远程和本地工作完全不同。于是我们发明了AMIs (Amazon Machine Images) 、 VMDKs (VMware images) 、 Vagrantfiles 等等, 一切又很顺利。

嗯，这些都很不错。这些包很大，也并非标准化，所以很难有效地运输。因此，我们发明了缓存(caching)。一切又又很顺利
正是caching使得 Docker 映像比 vmdks 或vagrantfiles更加有效。它允许我们在一些常见的基础映像上运输增量，而不是移动整个映像。这意味着我们有能力把整个环境从一个地方运送到另一个地方。这就是为什么当你“ docker run whatever”的时候，即使它描述了整个操作系统映像，它也会立即开始运行。我们将在(N 部分)中更详细地讨论这是如何工作的。

这就是容器的意义所在。它们是基于捆绑依赖关系的，这样我们就可以用可重复、安全的方式发送代码。但这是高层次的目标，而不是定义。我们来谈谈实际吧。

## 创建一个容器
所以(这次是真的!)什么是容器？如果创建一个容器就像 create _ Container 系统调用那样简单就好了。可惜不是，不过很接近了。要在底层讨论容器，我们必须讨论三样东西。分别是命名空间(namespace)、 cgroup 和分层文件系统(layered filesystems)。虽然还有其他的东西，不过这三者是这个魔术的主要组成部分。

### 命名空间 Namespace
命名空间提供了在一台计算机上运行多个容器所需的隔离（环境），同时为每个容器提供看起来像是它自己的环境的东西。就目前来说命名空间有 6 个，每个都可以被独立地请求，相当于给一个进程(及其子进程)一个机器资源子集的视图

命名空间有：
* PID：Pid 命名空间为进程及其子进程提供了系统中这些进程子集的视图。可以把它想象成一个映射表。当 pid 命名空间中的进程向内核请求进程列表时，内核查看映射表。如果进程存在于表中，则使用映射的 ID 而不是真正的 ID。如果它不存在于映射表中，内核就假装它根本不存在。Pid 名命名空间创建 pid 1中创建的第一个进程(通过将其主机 ID 映射为1)，展现出容器中的隔离进程树。
* MNT：在某种程度上，这是最重要的。Mount 命名空间为进程提供了它们自己的 mount 表。这意味着它们可以在不影响其他名称空间的情况下挂载和卸载目录（包括主机命名空间），更重要的是，结合 pivot _ root 系统调用 ，它允许进程拥有自己的文件系统。这就是我们如何让一个进程认为它在 ubuntu、 busybox 或者 alpine 上运行的方法——通过交换容器的文件系统能够发现
* NET：网络命名空间为使用它的进程提供它们自己的网络栈。一般来说，只有主网络名称空间(当您开始使用计算机时启动的进程)实际上会附加任何实际的物理网卡。但是我们可以创建虚拟以太网对一一连接的以太网卡，其中一端可以放在一个网络名称空间中，另一端可以放在另一个网络名称空间中，从而在网络名称空间之间创建一个虚拟链接。这有点像在一台主机上有多个 IP 协议栈相互通信。通过一点路由魔术，允许每个容器与现实世界对话，同时将每个容器与其自己的网络栈隔离开来。
* UTS：UTS 命名空间为其进程提供了它们自己的系统主机名和域名视图。输入 UTS 命名空间后，设置主机名或域名不会影响其他进程。
* IPC：IPC 命名空间隔离各种行程间通讯机制，例如消息队列。
* USER：用户名称空间是最近添加的，从安全角度来看，它可能是最强大的。用户名称空间将进程看到的 uid 映射到主机上的一组不同的 uid (以及 gids)。这很有用。使用用户名称空间，我们可以将容器的根用户 ID (即0)映射到主机上的任意(以及无特权的) uid。这意味着我们可以让容器认为它具有 root 访问权限——我们甚至可以在特定于容器的资源上给它类似于 root 的权限——而不必在根名称空间中给它任何特权。容器可以自由地以 uid0的形式运行进程——它通常等同于拥有 root 权限——但是内核实际上是将这个 uid 映射到一个非特权的实际 uid。大多数容器系统不会将容器中的任何 uid 映射到调用名称空间中的 uid0：换句话说，容器中根本没有具有真正 root 权限的 uid。

大多数容器技术将用户的过程放入上述所有名称空间，并初始化名称空间以提供标准环境。例如，这相当于在容器的隔离网络名称空间中创建一个初始 Internet 卡，并与主机上的实际网络连接。

### CGroups
Cgroup 可以诚实地成为它们自己的整篇文章(我保留编写一篇文章的权利!)。我将在这里相当简短地介绍它们，因为一旦您理解了这些概念，您就可以直接在文档中找到很多内容。基本上，cgroup 将一组进程或任务 ID 集合在一起，并对它们应用限制。在名称空间隔离进程的地方，cgroup 强制进程之间进行公平(或不公平——这取决于您，疯狂吧)的资源共享。

内核将 Cgroup 公开为一个可以挂载的特殊文件系统。通过简单地将进程 ID 添加到任务文件，可以将进程或线程添加到 cgroup，然后通过编辑该目录中的文件来读取和配置各种值。

### 分层文件系统



