## GPM 调度

* 每个G 是一个协程，类似于线程，但是更轻量级，这里这要理解，是Golang 应用程序调度的最小单位即可。  
* 每个P 绑定一个 M ，基于自己的队列完成基于 G 的调度  
* 每个M 对应着一个计算机核心线程  

G: Gourtines（携带任务）, 每个Goroutine对应一个G结构体，G保存Goroutine的运行堆栈，即并发任务状态。
G并非执行体，每个G需要绑定到P才能被调度执行。

P: Processors（分配任务）, 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。
对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等

M: Machine（寻找任务）, OS线程抽象，负责调度任务，和某个P绑定，从P的runq中不断取出G，切换堆栈并执行，M本身不具备执行状态，
在需要任务切换时，M将堆栈状态写回G，任何其它M都能据此恢复执行。
