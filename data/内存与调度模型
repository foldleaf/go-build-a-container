## 内存模型
https://mp.weixin.qq.com/s/pjxIbAsVzkdXI7KFSeE8hQ  
https://www.ququ123.top/2022/04/golang_gmp_principle/
## GPM调度模型
GPM调度模型是Go语言的并发机制，它是一种m:n调度的技术，也就是说，它可以复用/调度m个goroutine到n个OS线程1。goroutine是Go语言的轻量级线程，它可以在用户态下完成调度，不需要频繁切换到内核态，因此效率很高1。

GPM调度模型包括四个重要的结构，分别是G、P、M、Sched2：

G：Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行2。
P：Processor，表示逻辑处理器，对G来说，P相当于CPU核，G只有绑定到P才能被调度。对M来说，P提供了相关的执行环境，如内存分配状态、任务队列等。P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数>=P的数量）2。
M：Machine，表示物理线程，对应操作系统的线程。M负责执行G，一个M必须绑定一个P才能执行G，一个P可以被多个M绑定，但是同一时刻只能被一个M绑定。M可以在不同的P之间切换，以实现负载均衡2。
Sched：Scheduler，表示调度器，它维护了一个全局的P队列、M队列、G队列，以及一些调度相关的参数。Sched负责协调P、M、G之间的关系，以及处理G的抢占、阻塞、唤醒等事件23。
GPM调度模型的工作流程大致如下：

当Go程序启动时，运行时会创建一个名为sysmon的M（监控线程），以及一些P和M，P的数量默认等于CPU核数，M的数量默认等于P的数量加13。
每个P会从Sched的全局G队列或者其他P的本地G队列中获取一个G，然后绑定到一个M上，开始执行G的任务函数2。
当G执行完毕或者被抢占、阻塞、唤醒等事件发生时，P会将G放回到本地G队列或者全局G队列中，然后再从队列中获取一个新的G，继续执行2。
当P没有可执行的G时，P会尝试从其他P的本地G队列中窃取一半的G，如果还是没有，P会将自己放入到Sched的全局P队列中，等待被唤醒2。
当M没有绑定的P时，M会尝试从Sched的全局P队列中获取一个P，如果没有，M会将自己放入到Sched的全局M队列中，等待被唤醒2。
sysmon会定期检查P、M、G的状态，以及CPU的使用情况，根据需要创建或者销毁P、M，以及唤醒或者抢占G3
